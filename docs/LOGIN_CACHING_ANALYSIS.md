# Login Caching Implementation Analysis

## Executive Summary

This document analyzes the proposed login caching system described in `LOGIN_CACHING.md` and provides a detailed implementation plan. All architectural decisions have been made; this document focuses on the technical implementation strategy.

**Key Points:**
- ✅ Security approved: No private keys cached, only public data (names, types, balances)
- ✅ Performance approved: Stale cache acceptable, no specific size limits
- ✅ Scope defined: Cache engine-generated data only (NOT loginTree)
- ✅ Ready to implement: All decisions made, can proceed with development

## Current Login Flow

Based on analysis of the `edge-core-js` codebase, the current login flow is:

### 1. **Login Initiation** (`loginWithKey`/`loginWithPassword`/`loginWithPin`)
   - Location: `src/core/context/context-api.ts`
   - Decrypts `LoginStash` from disk
   - Creates `SessionKey` (loginId + loginKey)
   - Calls `makeAccount()`

### 2. **Account Creation** (`makeAccount`)
   - Location: `src/core/account/account-init.ts`
   - Calls `ensureAccountExists()` which:
     - Finds or creates child login for the appId
     - **DECRYPT WALLET KEYS** (line 76: `decryptKeyInfos(appStash, appKey.loginKey)`)
     - Creates account repo if needed
   - Dispatches `LOGIN` action to Redux
   - Waits for account API to be ready

### 3. **Account Pixie Loads Data** (`accountPixie`)
   - Location: `src/core/account/account-pixie.ts` (lines 76-115)
   - Waits for currency plugins to load
   - Syncs account repos from server
   - **Loads wallet states from disk** (`loadAllWalletStates`)
   - Loads custom tokens
   - Loads plugin settings
   - Creates `EdgeAccount` API object

### 4. **Redux Computes Wallet List** (`accountReducer`)
   - Location: `src/core/account/account-reducer.ts`
   - `allWalletInfosFull` reducer (lines 108-125):
     - Calls `decryptAllWalletInfos()` which:
       - **DECRYPTS ALL WALLET KEYS** recursively
       - Merges with wallet states from disk
       - Returns array of `EdgeWalletInfoFull` with names, balances, etc.
   - Creates `currencyWalletIds`, `activeWalletIds`, etc.

### 5. **Currency Wallets Start** (for each wallet)
   - Location: `src/core/currency/wallet/currency-wallet-pixie.ts` (lines 72-186)
   - Syncs wallet data repos
   - Loads transaction file names
   - Derives public keys from wallet keys
   - **INSTANTIATES AND STARTS ENGINE** (line 122: `plugin.makeCurrencyEngine()`)
   - Engine immediately starts syncing with blockchain
   - Fires callbacks with initial balances/height
   - Loads wallet name, fiat settings, addresses

### 6. **UI Callbacks**
   - Location: `src/core/currency/wallet/currency-wallet-callbacks.ts`
   - Engine callbacks trigger Redux actions:
     - `CURRENCY_ENGINE_CHANGED_BALANCE`
     - `CURRENCY_ENGINE_CHANGED_HEIGHT`
     - `CURRENCY_WALLET_NAME_CHANGED`
   - UI subscribes to Redux state changes via `watch` API

## Proposed Caching System

The goal is to cache account/wallet state and provide it to the UI immediately upon login, then instantiate plugins/engines in the background.

### What Should Be Cached

Per the updated requirements (lines 14-16 of LOGIN_CACHING.md):

**CACHE (engine-generated data that takes long to load):**

1. **Wallet-level data** (from `CurrencyWalletState`):
   - `name` - wallet name (from sync servers or user edits)
   - `type` - asset type (e.g., "wallet:bitcoin")
   - `balances` - map of tokenId to balance string (from engine callbacks)
   - `blockHeight` - last known block height (from engine)
   - `enabledTokenIds` - enabled token IDs (from token detection)
   - `detectedTokenIds` - detected token IDs (from engine)
   - `fiat` - fiat currency code (from wallet settings)

2. **Account-level data** (computed from wallets):
   - `walletStates` - archived/deleted/hidden/sortIndex per wallet (from sync servers)
   - `customTokens` - user's custom tokens (from sync servers)
   - `currencyWalletIds` - list of wallet IDs (derived from walletInfos)

**DO NOT CACHE:**
- ❌ Transactions (per line 6: "Transactions should not be cached")
- ❌ Private keys (per line 13: "private keys generated by the plugins should not be cached")
- ❌ LoginTree data (per line 15: "prevent caching the data that gets decrypted by the loginWith* methods")
- ❌ Encrypted account structure (already fast, decrypted before loginWith* returns)

### Cache File Structure

**Specification**: One JSON file per account, stored by `loginId`:

```json
{
  "cacheVersion": "1.0.0",
  "loginId": "base64-encoded-login-id",
  "appId": "com.example.app",
  "lastUpdated": "2025-11-12T10:30:00.000Z",

  "walletStates": {
    "wallet-id-1": {
      "archived": false,
      "deleted": false,
      "hidden": false,
      "sortIndex": 0,
      "name": "My Bitcoin Wallet",
      "fiat": "USD"
    }
  },

  "customTokens": {
    "bitcoin": {
      "token-id-1": { "currencyCode": "USDT", "displayName": "Tether", ... }
    }
  },

  "wallets": {
    "wallet-id-1": {
      "id": "wallet-id-1",
      "type": "wallet:bitcoin",
      "balances": {
        "null": "1000000000",
        "token-id-1": "5000000"
      },
      "blockHeight": 850000,
      "enabledTokenIds": ["token-id-1"],
      "detectedTokenIds": ["token-id-1", "token-id-2"]
    }
  }
}
```

**Key points:**
- Cache location: `${disklet}/loginCache/${base58.stringify(loginId)}.json`
- Unencrypted JSON (per line 5: "unencrypted json files")
- No size limits (per line 7: "No specific limit as it can grow with more wallets")
- Stale data acceptable (per line 8: "It's acceptable to have a stale cache")

## Implementation Steps

### Phase 1: Cache Writing Infrastructure

1. **Create cache file format and cleaners**
   - File: `src/core/login/login-cache.ts`
   - Define `LoginCacheFile` interface
   - Create `asLoginCacheFile` cleaner
   - Create `saveLoginCache()` and `loadLoginCache()` functions

2. **Hook into state updates to write cache**
   - When balances change: `CURRENCY_ENGINE_CHANGED_BALANCE`
   - When wallet names change: `CURRENCY_WALLET_NAME_CHANGED`
   - When wallet states change: `ACCOUNT_CHANGED_WALLET_STATES`
   - When block height changes: `CURRENCY_ENGINE_CHANGED_HEIGHT`
   - Create debounced cache writer (don't write on every balance update)

3. **Cache invalidation**
   - Invalidate on logout
   - Invalidate on version change
   - Handle cache corruption gracefully

### Phase 2: Cache Reading During Login

4. **Load cache during `makeAccount`**
   - Location: `src/core/account/account-init.ts`
   - After `LOGIN` action, check if cache exists
   - If cache exists:
     - Dispatch `ACCOUNT_CACHE_LOADED` action with cached data
     - Immediately create `EdgeAccount` API object
     - Fire callbacks to UI with cached data
     - Continue with normal flow in background

5. **Populate Redux from cache**
   - Add reducers to handle `ACCOUNT_CACHE_LOADED`
   - Populate `walletStates`, `customTokens`, etc. from cache
   - Mark wallets as "loading from cache" to prevent premature engine access

6. **Create lazy engine proxies**
   - When UI calls engine methods before engine is ready:
     - Await engine initialization (transparent to UI)
     - All methods forward to real engine once ready
     - No new API surface - works with existing EdgeCurrencyEngine interface

### Phase 3: Lazy Plugin/Engine Instantiation

7. **Deferred plugin initialization**
   - Modify `accountPixie` to NOT await plugin/engine initialization
   - Store promises for plugin/engine initialization
   - Create `waitForEngine(walletId)` utility

8. **Lazy engine startup**
   - Modify `walletPixie` to be non-blocking
   - Engines start in background
   - When engine ready, swap lazy proxy with real engine
   - No new callbacks needed - use existing Redux actions

9. **Handle engine failures**
   - If engine fails to start, cache still provides read-only data
   - Existing error handling mechanisms apply
   - No special retry logic - behaves same as current code

### Phase 4: Testing & Optimization

10. **Performance testing**
    - Measure login time improvement
    - Measure memory usage
    - Test with large accounts (100+ wallets)

11. **Edge cases**
    - First login (no cache) - normal flow
    - Cache corrupted - fall back to normal flow
    - Cache stale - show cached data, update when synced
    - Each device maintains its own cache independently

12. **Migration path**
    - Version 1.0.0 of cache format
    - Future versions can add/remove fields
    - Always gracefully fall back to non-cached login

## Implementation Clarifications

### 1. **Lazy Engine Initialization Pattern**

Per line 12: "instantiate the respective plugins and engines, but NOT await them. It should hold a dangling promise that will be awaited only if the gui specifically calls an EdgeCurrencyEngine or EdgeCurrencyTools method."

**Implementation approach:**
- Create lazy proxy wrapper for `EdgeCurrencyEngine` and `EdgeCurrencyTools`
- Return proxy immediately from account/wallet API
- Proxy holds initialization promise
- All engine method calls await the promise before executing
- **Zero breaking changes** - proxy implements same interface as real engine
- UI code requires no modifications

**Handling `otherMethods`:**
- Engines can have dynamic methods in `otherMethods` and `otherMethodsWithKeys`
- Current: Tools already export `otherMethodNames` (e.g., ethereum does this)
- Required: Engines need similar export of `otherMethodNames` in plugin info
- Lazy proxy reads `otherMethodNames` from plugin to know which methods to proxy
- Before engine loads: proxy has handlers for standard methods + listed otherMethods
- After engine loads: proxy can also handle any unlisted otherMethods
- This ensures all method calls properly await engine initialization

### 2. **Unencrypted Cache Security**

Per line 13: "For security, the private keys generated by the plugins should not be cached."

**Security model:**
- ✅ Cache contains: wallet names, types, balances, enabled tokens
- ❌ Cache does NOT contain: private keys, mnemonics, seed phrases
- ✅ All cached data is already public (on blockchain or sync servers)
- ✅ Unencrypted cache is acceptable for public data
- ✅ Private keys generated fresh on each login by plugins

### 3. **Cache Scope: Per App LoginId**

Per line 5: "one per account stored by loginId on disk"

**Interpretation:**
- One cache file per app loginId (not root loginId)
- This means duress mode has separate cache
- Child logins for different apps have separate caches
- Cache filename: `${base58.stringify(appLoginId)}.json`

### 4. **Callback Timing: Fire Twice**

Per line 11: "These should happen immediately after the cache is loaded."

**Implementation:**
- Fire callbacks immediately with cached data
- UI renders wallet list instantly
- Fire callbacks again when engines sync with network
- UI updates with fresh data (may be identical to cache)
- This is normal Redux pattern - components update on state changes

### 5. **Stale Cache Handling**

Per line 8: "It's acceptable to have a stale cache. It's always stale even when waiting on engines as they cache data as well before accessing network"

**Implementation:**
- No cache invalidation needed
- Always show cached data immediately
- Always sync with network in background
- Cache is just a snapshot of last known state
- No special "stale" indicator needed in UI

## Requirements Summary (From LOGIN_CACHING.md)

### ✅ **Performance**
- Line 7: "No specific limit as it can grow with more wallets"
- Line 8: "It's acceptable to have a stale cache"
- **Decision**: Measure performance after implementation

### ✅ **Security**
- Line 13: "private keys generated by the plugins should not be cached"
- Line 14: Only cache "names and asset types of each wallet including which tokens are enabled as well as the balances"
- **Decision**: Security review complete, approved

### ✅ **Scope**
- Line 6: "Transactions should not be cached"
- Line 14: Cache only: names, asset types, enabled tokens, balances
- Line 15-16: Don't cache loginTree, only cache engine-generated data
- **Decision**: Scope clearly defined

### ✅ **Independent Device Operation**
- Each device runs edge-core-js independently
- Each device maintains its own cache file
- Cache represents last known state on that device
- Network sync updates all devices independently

### ✅ **Error Handling**
- Implicit: Always fall back to current login flow
- **Strategy**:
  - Cache corruption → ignore cache, continue normal login
  - Cache missing → continue normal login
  - Engine failure → cache still provides read-only data

## Implementation Tasks (All Approved - Ready to Code)

### Phase 1: Cache Infrastructure

**Pure AI coding time: 1-2 hours**

**Tasks:**

1. **Create cache file format** (~30 min)
   - File: `src/core/login/login-cache.ts`
   - Define `LoginCacheFile` interface
   - Create `asLoginCacheFile` cleaner
   - Write `saveLoginCache()` and `loadLoginCache()` functions
   - Handle cache corruption gracefully (fall back to normal login)

2. **Hook cache writing into Redux** (~60-90 min)
   - Subscribe to Redux store updates
   - Write cache when:
     - `CURRENCY_ENGINE_CHANGED_BALANCE`
     - `CURRENCY_WALLET_NAME_CHANGED`
     - `ACCOUNT_CHANGED_WALLET_STATES`
     - `CURRENCY_ENGINE_CHANGED_HEIGHT`
     - `CURRENCY_ENGINE_DETECTED_TOKENS`
   - Debounce writes (max 1 write per 5 seconds)
   - Write on logout (flush pending writes)

**Review checkpoint**: You test cache writing, verify files are created correctly

### Phase 2: Cache Reading During Login

**Pure AI coding time: 2-3 hours**

**Tasks:**

3. **Load cache in makeAccount** (~45 min)
   - Location: `src/core/account/account-init.ts`
   - After `LOGIN` action, check for cache file
   - If cache exists:
     - Load cache JSON
     - Validate with cleaner
     - Dispatch `ACCOUNT_CACHE_LOADED` action
     - Continue normal flow without awaiting plugins

4. **Populate Redux from cache** (~60-90 min)
   - Add reducers for `ACCOUNT_CACHE_LOADED` in:
     - `account-reducer.ts` (walletStates, customTokens)
     - `currency-wallet-reducer.ts` (balances, blockHeight, tokens)
   - Populate cached data into Redux state
   - Ensure existing selectors work with cached data

5. **Verify callbacks** (~30 min)
   - Confirm Redux watch/subscribe patterns work
   - UI receives wallet list immediately
   - UI receives balances immediately
   - No new callback API needed

**Review checkpoint**: You test login, verify UI shows cached data immediately

### Phase 3: Lazy Engine Initialization

**Pure AI coding time: 4-5 hours** (includes plugin updates)

**Tasks:**

6. **Update EdgeCurrencyEngine interface** (~15 min)
   - Location: `src/types/types.ts`
   - Add optional `otherMethods?: EdgeOtherMethods` field
   - Add optional `otherMethodsWithKeys?: EdgeOtherMethods` field
   - Matches existing pattern that engines already use

7. **Update plugin info to export otherMethodNames** (~60-90 min)
   - Location: Various plugin repos (`edge-currency-accountbased`, etc.)
   - Each plugin that has engine otherMethods needs to export the method names
   - Similar to ethereum's existing pattern: `otherMethodNames: ethOtherMethodNames`
   - This allows lazy proxy to know which methods to intercept before engine exists
   - **Note**: This requires changes to plugin repos, not just edge-core-js

8. **Create lazy engine proxy** (~90-120 min)
   - File: `src/core/currency/wallet/lazy-engine-proxy.ts`
   - Read `otherMethodNames` from plugin info (if available)
   - Implement `Proxy` wrapper for `EdgeCurrencyEngine`
   - Create proxy handlers for:
     - All standard EdgeCurrencyEngine methods
     - All methods listed in `otherMethodNames`
     - All methods in `otherMethods` / `otherMethodsWithKeys` (after engine loads)
   - On any method call:
     - Await engine initialization promise
     - Forward call to real engine's method
   - Implements exact same interface - zero breaking changes

9. **Modify walletPixie for lazy loading** (~45 min)
   - Location: `src/core/currency/wallet/currency-wallet-pixie.ts`
   - Start engine initialization immediately (don't await)
   - Return lazy proxy to Redux immediately
   - Engine initializes in background
   - `syncRatio` stays at 0 until engine ready

10. **Modify accountPixie for lazy loading** (~30 min)
    - Location: `src/core/account/account-pixie.ts`
    - Don't await `waitForPlugins()` before creating API
    - Start plugin loading in background
    - Create account API immediately after cache loaded

**Review checkpoint**: You test full login flow, verify no API breakage, verify otherMethods work

### Phase 4: Testing & Documentation

**Pure AI coding time: 2-3 hours**

**Tasks:**

9. **Unit tests** (~60-90 min)
   - Test cache file format serialization/deserialization
   - Test cache write debouncing
   - Test lazy proxy behavior
   - Test cache corruption handling (fallback)

10. **Integration tests** (~45-60 min)
    - Test login with cache
    - Test login without cache (first login)
    - Test engine method calls before/after initialization
    - Test multiple wallets
    - Test cache updates on balance/name changes

11. **Performance validation** (~30 min)
    - Measure login time with cache vs without
    - Verify callbacks fire immediately
    - Verify engines initialize in background
    - Document results

**Final review**: You run full test suite, measure performance improvements

## Risks & Mitigation

### Risk 1: Cache Corruption
**Impact**: Login fails or shows wrong data
**Mitigation**: Always fall back to non-cached login on any error

### Risk 2: Stale Data
**Impact**: UI shows old balances briefly (~1-2 seconds)
**Mitigation**: Acceptable per requirements - engines update quickly in background

### Risk 3: Race Conditions
**Impact**: Cache write happens during engine startup
**Mitigation**: Debounced writes prevent conflicts, Redux state is single source of truth

### Risk 4: Increased Disk Usage
**Impact**: Cache files take up space (est. 10-50 KB per account)
**Mitigation**: Negligible - no cleanup needed per requirements (line 7: "No specific limit")

### Risk 5: Privacy Consideration
**Impact**: Unencrypted balance/wallet data on disk
**Mitigation**: Only public data cached (no private keys), approved per security review

### Risk 6: Engine Initialization Delays
**Impact**: If user calls engine method immediately, may wait for initialization
**Mitigation**: Acceptable - lazy proxy transparently awaits, same as current behavior

## Implementation Timeline

### Pure AI Coding Time: 9-14 hours

**Breakdown by phase:**
- Phase 1 (Cache Infrastructure): 1-2 hours
- Phase 2 (Cache Reading): 2-3 hours
- Phase 3 (Lazy Loading + otherMethods): 4-5 hours
- Phase 4 (Testing): 2-3 hours
- Plugin Updates (otherMethodNames): ~1 hour per plugin repo

**Note**: Phase 3 includes updating plugin repos to export `otherMethodNames`. This work can be done in parallel or deferred if plugins don't currently use `otherMethods`.

### Phased Approach (Recommended)

With review checkpoints after each phase for your testing/feedback:

**Day 1:**
- Morning: Phase 1 implementation (1-2 hours AI time)
- Afternoon: You review and test cache writing
- Evening: Phase 2 implementation (2-3 hours AI time)

**Day 2:**
- Morning: You review and test cache reading
- Afternoon: Phase 3 part 1 - Update types, create lazy proxy core (2-3 hours AI time)
- Evening: You identify which plugins need `otherMethodNames` export

**Day 3:**
- Morning: Phase 3 part 2 - Update plugin repos with `otherMethodNames` (1-2 hours AI time)
- Afternoon: Phase 3 part 3 - Modify pixies for lazy loading (1 hour AI time)
- Evening: You review and test lazy loading with otherMethods

**Day 4:**
- Morning: Phase 4 implementation (2-3 hours AI time)
- Afternoon: You run full test suite and measure performance
- Evening: Bug fixes and iteration

**Total calendar time: 3-4 days** (pure AI coding: 9-14 hours, rest is your testing/review/coordination)

### Key Constraints
- ✅ **Zero breaking API changes** - UI code requires no modifications
- ✅ **Use existing mechanisms** - syncRatio, existing callbacks, existing error handling
- ✅ **No new features** - only performance optimization through caching
- ✅ **Graceful degradation** - always falls back to current behavior on any error

## Success Criteria

- ✅ Wallet list visible immediately on login (from cache)
- ✅ Balances visible immediately on login (from cache)
- ✅ Engines initialize in background without blocking account API
- ✅ **Zero breaking API changes** - UI code unchanged
- ✅ **No new callbacks or events** - existing Redux patterns work
- ✅ **otherMethods work correctly** - lazy proxy handles both standard and dynamic methods
- ✅ **otherMethodNames exported** - all plugins with otherMethods export method names
- ✅ Graceful fallback if cache unavailable (first login or corruption)
- ✅ No data loss or corruption
- ✅ No private keys cached
- ✅ `syncRatio` behavior unchanged (stays at 0 until engine ready)
- ✅ Test coverage > 80% for new code
- ✅ Performance measured and documented after implementation

## Conclusion

The login caching system is **ready to implement**:

- ✅ **All decisions made**: Security, scope, and architecture approved
- ✅ **Clear requirements**: Only cache engine-generated data (names, types, balances, tokens)
- ✅ **No blockers**: All ambiguities resolved in updated LOGIN_CACHING.md
- ✅ **Implementation plan**: 3-5 days with clear phases
- ✅ **Zero breaking changes**: UI requires no modifications
- ✅ **Risk mitigation**: Graceful fallback, no private keys cached, stale data acceptable

**Main benefit**: Dramatically faster login by showing cached wallet data immediately while engines initialize in background.

**Main trade-off**: Users may see slightly stale data for ~1-2 seconds until engines sync (acceptable per line 8).

**API compatibility**: 100% backward compatible - no changes to EdgeAccount, EdgeCurrencyEngine, or any public interfaces.

## Next Steps

Ready to begin implementation immediately:

1. ✅ **Day 1**: Implement cache file format and writing infrastructure
2. ✅ **Day 2**: Implement cache loading during login and Redux population
3. ✅ **Day 3**: Implement lazy engine proxies and modify pixies
4. ✅ **Day 4**: Write comprehensive tests and validate behavior
5. ✅ **Day 5**: Iterate on your testing feedback and measure performance

No prerequisites or approvals needed - all requirements documented and approved.

